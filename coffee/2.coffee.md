# First-Class Functions and Applicative Programming

    _ = require 'underscore'
    {deepEqual, ok} = require 'assert'

    eq = deepEqual

---

    stanza = (n) ->
      _.chain([])
       .push(n + " bottles of beer on the wall")
       .push(n + " bottles of beer")
       .push("Take one down, pass it around")
       .push(
         if n > 1
           "#{--n} bottles of beer on the wall."
         else
            "No more bottles of beer on the wall!"
       )
       .value()
       .join('\n')

    ok stanza(2) is
      '''
      2 bottles of beer on the wall
      2 bottles of beer
      Take one down, pass it around
      1 bottles of beer on the wall.
      '''

    song = (start, end, stanza) -> 
      iter = (acc, n) -> acc.concat stanza(n)
      [start..end]
        .reduce(iter, [])
        .join('\n')

    ok song(2, 1, stanza) is
      '''
      2 bottles of beer on the wall
      2 bottles of beer
      Take one down, pass it around
      1 bottles of beer on the wall.
      1 bottles of beer on the wall
      1 bottles of beer
      Take one down, pass it around
      No more bottles of beer on the wall!
      '''

---

    nums = [1..5]

    double = (nums) ->
      nums.map (n) -> n * 2

    eq double(nums), [2, 4, 6, 8, 10]

    avg = (nums) ->
      sum = nums.reduce((memo, next) -> memo + next)
      sum / nums.length

    evens = (nums) ->
      nums.filter (n) -> not (n % 2)

    eq evens(nums), [2, 4]

---

    ###

    allOf() {
      return _.reduceRight(arguments, function(truth, f) {
        return truth && f();
      }, true);
    }

    function anyOf() {
      return _.reduceRight(arguments, function(truth, f) {
        return truth || f();
      }, false);
    }

    function complement(pred) {
      return function() {
        return !pred.apply(null, _.toArray(arguments));
      };
    }

    function cat() {
      var head = _.first(arguments);
      if (existy(head))
        return head.concat.apply(head, _.rest(arguments));
      else
        return [];
    }

    cat([1,2,3], [4,5], [6,7,8]);
    //=> [1, 2, 3, 4, 5, 6, 7, 8]

    function construct(head, tail) {
      return cat([head], _.toArray(tail));
    }

    construct(42, [1,2,3]);
    //=> [42, 1, 2, 3]

    function mapcat(fun, coll) {
      return cat.apply(null, _.map(coll, fun));
    }

    function butLast(coll) {
      return _.toArray(coll).slice(0, -1);
    }

    function interpose (inter, coll) {
      return butLast(mapcat(function(e) {
        return construct(e, [inter]);
      },
      coll));
    }

    var zombie = {name: "Bub", film: "Day of the Dead"};

    _.keys(zombie);
    //=> ["name", "film"]

    _.values(zombie);
    //=> ["Bub", "Day of the Dead"]

    var library = [{title: "SICP", isbn: "0262010771", ed: 1},
                  {title: "SICP", isbn: "0262510871", ed: 2},
                  {title: "Joy of Clojure", isbn: "1935182641", ed: 1}];

    _.findWhere(library, {title: "SICP", ed: 2});

    //=> {title: "SICP", isbn: "0262510871", ed: 2}

    function project(table, keys) {
      return _.map(table, function(obj) {
        return _.pick.apply(null, construct(obj, keys));
      });
    };

    function rename(obj, newNames) {
      return _.reduce(newNames, function(o, nu, old) {
        if (_.has(obj, old)) {
          o[nu] = obj[old];
          return o;
        }
        else
          return o;
      },
      _.omit.apply(null, construct(obj, _.keys(newNames))));
    };

    function as(table, newNames) {
      return _.map(table, function(obj) {
        return rename(obj, newNames);
      });
    };

    function restrict(table, pred) {
      return _.reduce(table, function(newTable, obj) {
        if (truthy(pred(obj)))
          return newTable;
        else
          return _.without(newTable, obj);
      }, table);
    };

    ###
