# Higher Order Functions

Underscore and testing utils used below.

    _ = require 'underscore'
    {ok, deepEqual} = require 'assert'
    eq = deepEqual


## Functions That Take Other Functions

Underscore's `max` provides a way to compare arbitrary objects, returning the
maximum value within a collection. It takes an optional second argument, a
function that can be used to generate a numeric value from the object supplied
to it.

    fred = 
      name: 'Fred'
      age: 65
  
    lucy =
      name: 'Lucy'
      age: 36

    people = [fred, lucy]

    eq _.max(people, (p) -> p.age), fred

Note, however, that the comparison between values is always via the
numeric greater-than operator (`>`).

---

Alternatively ...

    oldest = people.reduce (max, next) -> 
      if max.age > next.age then max else next

    eq oldest, fred

---

We can of course define our own `max` function that takes an ordering function
as its first argument.

    max = (isGreater, arr) ->
      arr.reduce (x, y) -> if isGreater(x, y) then x else y

    nums = [1..5]

    isGreater = (x, y) -> x > y
    ok max(isGreater, nums) is 5

    isLess = (x, y) -> x < y
    ok max(isLess, nums) is 1

Alternatively, we can define a `best` function to find “best-fits” in a more flexible manner. It takes two functions: one to build a comparable value, and another to compare two values and return the “best” value of the two.

    best = (value, better, arr) ->
      arr.reduce (x, y) -> 
        X = value(x)
        Y = value(y)
        if X is better(X, Y) then x else y

    ok best(_.identity, Math.max, nums) is 5

    get = (key) ->
      (obj) -> obj and obj[key]

    eq best(get('age'), Math.max, people), fred, 'Fred is oldest at 65'
    eq best(get('age'), Math.min, people), lucy, 'Lucy is yountest at 36'

The implementation of `best` can be tightened up a bit if the supplied `better` function ...

* returns true if the first argument is “better” than the second 
* knows how to “unwrap” its arguments.

For example:

    best = (better, arr) ->
      arr.reduce (x, y) -> 
        if better(x, y) then x else y

    ok best(isGreater, nums) is 5
    ok best(isLess, nums) is 1

    older = (a, b) -> a.age > b.age
    eq best(older, people), fred, 'Fred is oldest at 65'


## More Thinking About Passing Functions

A discussion of how functions can be made more generic and the trade-offs of
doing so.

We start with `repeat`, which takes a number and a value and builds an array
containing some number `n` of the value, duplicated.


    repeat = (n, value) ->
      value for i in [0...n]

    eq repeat(3, 'x'), ['x', 'x', 'x']
    eq repeat(0, 'x'), []
    

### Use functions, not values!

While a function that repeats a value some number of times is good, a function that repeats a computation some number of times is better.

    repeatedly = (n, f) ->
      f(++i) for i in [0...n]       # supply function w/ current repeat count

    roll = -> Math.floor((Math.random() * 6) + 1)   # roll the dice

    rolls = repeatedly(10, roll)                    # a series of dice rolls

    ok rolls.length is 10
    ok(0 < r < 7) for r in rolls

Of course we can still duplicate constant values with `repeatedly`.

    eq repeatedly(3, -> 'x'), ['x', 'x', 'x']

Since `repeatedly` is implemented as a list comprehension iterating over a
range, a number representing the current repeat count is supplied to the function and could be used as you see fit.

    eq repeatedly(3, (i) -> i), [1, 2, 3]

What if we want to call a given function not a specified number of times, but
until a given condition is reached?

    iterTo = (f, check, next) ->
      next = f(next) while check(f(next))

This takes `repeatedly` to the next level in that now even the repeat count is
open-ended and subject to the result of a function call.

Note that the repeating loop is a feed-forward function. In other words, the result
of some call to the passed function is fed into the next call of the function
as its argument.

How would you use `iterateUntil`? A simple use case would be to collect all of
the results of some repeated computation until the value crosses some
threshold. For example, suppose you want to continually double some initial
value (`init`) up to some maximum. For example, let's repeatedly double our
starting value up to 1024.

    double = (n) -> n + n
    test = (n) -> n < 1025

    eq iterTo(double, test, init=1), 
       [2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]

To accomplish the same task with `repeatedly` requires that you know, before
calling, the number of times you need to call your function to generate the
correct array:

    eq repeatedly(10, (exp) -> Math.pow(2, exp)),
       [2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]


## Functions That Return Other Functions

A function returning a constant can actually be quite useful.

    K = (x) -> 
      -> x

Our `K` function captures a single value (or reference) and repeatedly
returns the same value. 

    hi = K('hi')

    ok hi() is 'hi'

Note how a captured function is always the same across invocations.

    f = K(->)
    ok f() is f()

    g = K(K)
    ok g() is g()

Also note how each new closure captures a unique value/reference.

    ok f() isnt g()
    ok K(K) isnt K(K)
    ok K(->) isnt K(->)

Any function created with `->` will return a unique instance, regardless of
the contents of its body.

We can now use `K` in lieu of anonymous functions.

    eq repeatedly(3, -> 'x'), ['x', 'x', 'x']
    eq repeatedly(3, K('x')), ['x', 'x', 'x']

---

Our `invoker` function takes a method and returns a function that will invoke 
that method on any object given. 

    ###
    function invoker (NAME, METHOD) {
      return function(target <args ...>) {
        if (!existy(target)) fail("Must provide a target");

        var targetMethod = target[NAME];
        var args = _.rest(arguments);

        return doWhen((existy(targetMethod) && METHOD === targetMethod), function() {
          return targetMethod.apply(target, args);
        });
      };
    };

    var rev = invoker('reverse', Array.prototype.reverse);

    _.map([[1,2,3]], rev);
    //=> [[3,2,1]]

    function uniqueString(len) {
      return Math.random().toString(36).substr(2, len);
    };

    uniqueString(10);
    //=> "3rm6ww5w0x"

    function uniqueString(prefix) {
      return [prefix, new Date().getTime()].join('');
    };

    uniqueString("argento");
    //=> "argento1356107740868"

    function makeUniqueStringFunction(start) {
      var COUNTER = start;

      return function(prefix) {
        return [prefix, COUNTER++].join('');
      }
    };

    var uniqueString = makeUniqueStringFunction(0);

    uniqueString("dari");
    //=> "dari0"

    uniqueString("dari");
    //=> "dari1"

    var generator = {
      count: 0,
      uniqueString: function(prefix) {
        return [prefix, this.count++].join('');
      }
    };

    generator.uniqueString("bohr");
    //=> bohr0

    generator.uniqueString("bohr");
    //=> bohr1

    var omgenerator = (function(init) {
      var COUNTER = init;

      return {
        uniqueString: function(prefix) {
          return [prefix, COUNTER++].join('');
        }
      };
    })(0);

    omgenerator.uniqueString("lichking-");
    //=> "lichking-0"

    var nums = [1,2,3,null,5];

    _.reduce(nums, function(total, n) { return total * n });
    //=> 0

    function fnull(fun /*, defaults>) {
      var defaults = _.rest(arguments);

      return function(<args>) {
        var args = _.map(arguments, function(e, i) {
          return existy(e) ? e : defaults[i];
        });

        return fun.apply(null, args);
      };
    };

    var safeMult = fnull(function(total, n) { return total * n }, 1, 1);

    _.reduce(nums, safeMult);
    //=> 30

    function defaults(d) {
      return function(o, k) {
        var val = fnull(_.identity, d[k]);
        return o && val(o[k]);
      };
    }

    function doSomething(config) {
      var lookup = defaults({critical: 108});

      return lookup(config, 'critical');
    }

    doSomething({critical: 9});
    //=> 9

    doSomething({});
    //=> 108

    function checker(<validators>) {
      var validators = _.toArray(arguments);

      return function(obj) {
        return _.reduce(validators, function(errs, check) {
          if (check(obj))
            return errs;
          else
            return _.chain(errs).push(check.message).value();
        }, []);
      };
    }

    function validator(message, fun) {
      var f = function(<args>) {
        return fun.apply(fun, arguments);
      };

      f['message'] = message;
      return f;
    }

    function aMap(obj) {
      return _.isObject(obj);
    }

    var checkCommand = checker(validator("must be a map", aMap));

    function hasKeys() {
      var KEYS = _.toArray(arguments);

      var fun = function(obj) {
        return _.every(KEYS, function(k) {
          return _.has(obj, k);
        });
      };

      fun.message = cat(["Must have values for keys:"], KEYS).join(" ");
      return fun;
    }

    var checkCommand = checker(validator("must be a map", aMap), hasKeys('msg', 'type'));

    ###
